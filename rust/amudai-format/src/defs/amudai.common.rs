// This file is @generated by prost-build.
/// `UInt64Range` is designed to represent a range of `u64` values with non-negative boundaries,
/// which can also be empty.
/// It can be used for various purposes, such as indicating a range of logical value positions within
/// an array or specifying a range of byte positions in a storage blob.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UInt64Range {
    /// Inclusive
    #[prost(fixed64, tag = "1")]
    pub start: u64,
    /// Exclusive
    #[prost(fixed64, tag = "2")]
    pub end: u64,
}
/// `UInt32Range` is designed to represent a range of `u32` value with non-negative boundaries,
/// which can also be empty.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UInt32Range {
    /// Inclusive
    #[prost(fixed32, tag = "1")]
    pub start: u32,
    /// Exclusive
    #[prost(fixed32, tag = "2")]
    pub end: u32,
}
/// `DataRef` provides a generic way to reference any piece of data within an Amudai shard.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DataRef {
    /// Reference to content within the blob specified by `url` (either relative or absolute one).
    /// Empty url means self-reference (data range in the "current" blob).
    #[prost(string, tag = "1")]
    pub url: ::prost::alloc::string::String,
    /// Data byte range, with absolute positions within the containing blob.
    /// `start` is inclusive, `end` is exclusive.
    /// An empty range is valid (`start == end`).
    #[prost(message, optional, tag = "2")]
    pub range: ::core::option::Option<UInt64Range>,
}
/// `DataRefArray` provides a "shredded" layout of `DataRef` collection for more efficient handling.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DataRefArray {
    #[prost(string, repeated, tag = "2")]
    pub url: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(fixed64, repeated, tag = "3")]
    pub start: ::prost::alloc::vec::Vec<u64>,
    #[prost(fixed64, repeated, tag = "4")]
    pub end: ::prost::alloc::vec::Vec<u64>,
}
/// `BytesList` is designed to efficiently handle sequences of variable-sized buffers
/// (either string or binary) by reducing the overhead associated with deserialization
/// and memory allocation.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BytesList {
    /// List of offsets within the data buffer. The first offset, `offsets\[0\]`, is always zero,
    /// and the length of offsets is one more than the number of buffers it represents.
    #[prost(fixed64, repeated, tag = "1")]
    pub offsets: ::prost::alloc::vec::Vec<u64>,
    /// `data` contains all the buffers concatenated together. Each buffer can be accessed
    /// using the formula `value\[i\] = data\[offsets[i\]..offsets\[i + 1]\]`.
    #[prost(bytes = "vec", tag = "2")]
    pub data: ::prost::alloc::vec::Vec<u8>,
}
/// Arbitrary primitive or composite constant value. This is a generalization of the built-in
/// Protobuf `Value` message, adapted to represent any scalar value within the basic Amudai
/// type system.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnyValue {
    /// An optional annotation, URL or resource name that identifies
    /// the semantic type of this value.
    #[prost(string, optional, tag = "30")]
    pub annotation: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(
        oneof = "any_value::Kind",
        tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 20, 21, 22"
    )]
    pub kind: ::core::option::Option<any_value::Kind>,
}
/// Nested message and enum types in `AnyValue`.
pub mod any_value {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Kind {
        #[prost(message, tag = "1")]
        NullValue(super::UnitValue),
        #[prost(bool, tag = "2")]
        BoolValue(bool),
        #[prost(uint64, tag = "3")]
        U64Value(u64),
        #[prost(int64, tag = "4")]
        I64Value(i64),
        #[prost(double, tag = "5")]
        DoubleValue(f64),
        #[prost(message, tag = "6")]
        DatetimeValue(super::DateTimeUtc),
        #[prost(message, tag = "7")]
        TimespanValue(super::TimeSpan),
        #[prost(string, tag = "8")]
        StringValue(::prost::alloc::string::String),
        #[prost(bytes, tag = "9")]
        BytesValue(::prost::alloc::vec::Vec<u8>),
        /// 16-byte d128 decimal representation
        #[prost(bytes, tag = "10")]
        DecimalValue(::prost::alloc::vec::Vec<u8>),
        #[prost(message, tag = "20")]
        ListValue(super::ListValue),
        #[prost(message, tag = "21")]
        StructValue(super::StructValue),
        #[prost(message, tag = "22")]
        DataRef(super::DataRef),
    }
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UnitValue {}
/// `DateTime` as defined in the `Type System` chapter
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DateTimeUtc {
    /// 100-nansosecond ticks passed since 0001-01-01
    #[prost(fixed64, tag = "1")]
    pub ticks: u64,
}
/// `TimeSpan` as defined in the `Type System` chapter
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TimeSpan {
    /// 100-nansosecond ticks
    #[prost(fixed64, tag = "1")]
    pub ticks: u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListValue {
    #[prost(message, repeated, tag = "1")]
    pub elements: ::prost::alloc::vec::Vec<AnyValue>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StructValue {
    #[prost(message, repeated, tag = "1")]
    pub fields: ::prost::alloc::vec::Vec<NameValuePair>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NameValuePair {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub value: ::core::option::Option<AnyValue>,
}
