// This file is @generated by prost-build.
/// Shard Directory serves as the starting point for accessing any shard operation.
/// It can be saved either in its own file, as part of a larger "shard directory"
/// file, or within the entire encoded shard blob.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ShardDirectory {
    /// Reference to a `Schema` message.
    #[prost(message, optional, tag = "1")]
    pub schema_ref: ::core::option::Option<super::common::DataRef>,
    /// Reference to a `ShardProperties` message.
    #[prost(message, optional, tag = "2")]
    pub properties_ref: ::core::option::Option<super::common::DataRef>,
    /// Reference to a `DataRefArray` (list of field descriptor refs).
    #[prost(message, optional, tag = "3")]
    pub field_list_ref: ::core::option::Option<super::common::DataRef>,
    /// Reference to a `StripeList` message.
    #[prost(message, optional, tag = "4")]
    pub stripe_list_ref: ::core::option::Option<super::common::DataRef>,
    /// Reference to a `UrlList` message.
    #[prost(message, optional, tag = "5")]
    pub url_list_ref: ::core::option::Option<super::common::DataRef>,
    /// Reference to a shard-scoped `IndexCollection` message.
    #[prost(message, optional, tag = "6")]
    pub indexes_ref: ::core::option::Option<super::common::DataRef>,
    #[prost(fixed64, tag = "7")]
    pub total_record_count: u64,
    #[prost(fixed64, tag = "8")]
    pub deleted_record_count: u64,
    #[prost(fixed64, tag = "9")]
    pub stripe_count: u64,
    #[prost(fixed64, optional, tag = "10")]
    pub raw_data_size: ::core::option::Option<u64>,
}
/// Standard and custom name-value pairs associated with the shard.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShardProperties {
    /// `creation_min` and `creation_max` define the range of timestamps marking
    /// the shard's creation period. When a shard is first created, both timestamps
    /// are identical. However, they may vary as shards undergo merging.
    #[prost(message, optional, tag = "1")]
    pub creation_min: ::core::option::Option<super::common::DateTimeUtc>,
    #[prost(message, optional, tag = "2")]
    pub creation_max: ::core::option::Option<super::common::DateTimeUtc>,
    #[prost(message, repeated, tag = "3")]
    pub standard_properties: ::prost::alloc::vec::Vec<super::common::NameValuePair>,
    #[prost(message, repeated, tag = "4")]
    pub custom_properties: ::prost::alloc::vec::Vec<super::common::NameValuePair>,
}
/// A list of all unique artifact URLs used within this shard, meaning they are referenced
/// by any of its `DataRef` elements.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UrlList {
    #[prost(string, repeated, tag = "1")]
    pub urls: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// The records within a shard are segmented into multiple horizontal data stripes.
/// Each shard contains at least one data stripe, with no set limit on stripe size;
/// a single stripe can encompass an entire shard.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StripeList {
    #[prost(message, repeated, tag = "1")]
    pub stripes: ::prost::alloc::vec::Vec<StripeDirectory>,
}
/// A complete directory of a stripe.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct StripeDirectory {
    /// Reference to a `StripeProperties` message.
    #[prost(message, optional, tag = "1")]
    pub properties_ref: ::core::option::Option<super::common::DataRef>,
    /// Reference to a `DataRefArray` stripe field descriptors list.
    #[prost(message, optional, tag = "2")]
    pub field_list_ref: ::core::option::Option<super::common::DataRef>,
    /// Reference to a stripe-scoped `IndexCollection` message.
    #[prost(message, optional, tag = "3")]
    pub indexes_ref: ::core::option::Option<super::common::DataRef>,
    #[prost(fixed64, tag = "4")]
    pub total_record_count: u64,
    #[prost(fixed64, tag = "5")]
    pub deleted_record_count: u64,
    #[prost(fixed64, optional, tag = "6")]
    pub raw_data_size: ::core::option::Option<u64>,
    /// The logical position of this stripe's first record within the containing
    /// shard.
    /// This represents the shard-absolute offset where this stripe begins.
    /// This value does not account for deleted records in preceding stripes.
    #[prost(fixed64, tag = "7")]
    pub shard_position: u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StripeProperties {
    #[prost(message, repeated, tag = "1")]
    pub standard_properties: ::prost::alloc::vec::Vec<super::common::NameValuePair>,
    #[prost(message, repeated, tag = "2")]
    pub custom_properties: ::prost::alloc::vec::Vec<super::common::NameValuePair>,
}
/// At the stripe level, a FieldDescriptor connects an abstract schema field definition
/// with its actual storage representation, including statistics and summaries of the values
/// in that stripe.
/// At the shard level, the FieldDescriptor only contains statistics for the field across
/// the entire shard.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FieldDescriptor {
    /// Indicates the number of logical "value slots" (logical positions)
    /// in this field's stored sequence.
    #[prost(fixed64, tag = "1")]
    pub position_count: u64,
    /// If present, this specifies the number of logical value slots containing `null` values.
    #[prost(fixed64, optional, tag = "2")]
    pub null_count: ::core::option::Option<u64>,
    /// If present, this indicates that all value slots contain the same value,
    /// including the possibility that all values are null. Such a field might
    /// not have any data encodings at the stripe level.
    #[prost(message, optional, tag = "3")]
    pub constant_value: ::core::option::Option<super::common::AnyValue>,
    /// Dictionary size
    #[prost(fixed64, optional, tag = "4")]
    pub dictionary_size: ::core::option::Option<u64>,
    /// Provides the minimum and maximum values for the stored sequence, where the range bounds
    /// may be inclusive or exclusive.
    #[prost(message, optional, tag = "6")]
    pub range_stats: ::core::option::Option<RangeStats>,
    /// Estimates the number of distinct values in the field, with null counted as a single
    /// distinct value.
    #[prost(message, optional, tag = "7")]
    pub cardinality: ::core::option::Option<CardinalityInfo>,
    /// Optional approximate membership query (AMQ) filters for the values of the field.
    /// Some MembershipFilters (notably SBBF) are only populated at the stripe level, not at the shard level.
    /// To determine if a value exists in a shard, queries must check the membership filters
    /// across all relevant stripes.
    #[prost(message, optional, tag = "8")]
    pub membership_filters: ::core::option::Option<MembershipFilters>,
    /// Optional indexes specific to the field (these can exist alongside multi-field indexes
    /// at the shard or stripe level).
    #[prost(message, optional, tag = "9")]
    pub indexes: ::core::option::Option<IndexCollection>,
    /// Additional properties associated with the field.
    #[prost(message, repeated, tag = "10")]
    pub standard_properties: ::prost::alloc::vec::Vec<super::common::NameValuePair>,
    #[prost(message, repeated, tag = "40")]
    pub custom_properties: ::prost::alloc::vec::Vec<super::common::NameValuePair>,
    /// Size of the data in its raw, uncompressed format in bytes.
    /// This represents the theoretical size of the data before any encoding, compression,
    /// or optimization is applied. The calculation includes both the actual data and
    /// null value metadata when applicable.
    ///
    /// For fixed-size data types (int32, int64, float32, float64, bool, etc.):
    ///    - Data size = (count of non-null values) * (size of data type in bytes)
    ///    - Example: 100 non-null int64 values = 100 * 8 = 800 bytes
    ///
    /// For variable-length data types (string, binary, lists, maps):
    ///    - Data size = sum of the length in bytes of all non-null values
    ///    - For strings: sum of UTF-8 byte lengths of all non-null strings
    ///    - For binary: sum of byte lengths of all non-null binary values
    ///    - For lists/maps: sum of the serialized byte lengths of all non-null containers
    ///
    /// Null value handling adds metadata overhead when nulls are present:
    ///    - If no null values: raw_data_size = data size only
    ///    - If some null values: raw_data_size = data size + null bitmap overhead
    ///      where null bitmap overhead = ceil(total_count / 8) bytes
    ///      (one bit per value position to indicate null/non-null, rounded up to byte boundary)
    ///    - If all values are null: raw_data_size = 0 (no data or bitmap needed)
    ///
    /// Examples:
    ///    - 1000 non-null int64 values: 1000 * 8 = 8000 bytes
    ///    - 1000 int64 values with 100 nulls: (900 * 8) + ceil(1000/8) = 7200 + 125 = 7325 bytes
    ///    - 1000 all-null values: 0 bytes
    #[prost(fixed64, optional, tag = "41")]
    pub raw_data_size: ::core::option::Option<u64>,
    #[prost(
        oneof = "field_descriptor::TypeSpecific",
        tags = "20, 21, 22, 23, 24, 25"
    )]
    pub type_specific: ::core::option::Option<field_descriptor::TypeSpecific>,
}
/// Nested message and enum types in `FieldDescriptor`.
pub mod field_descriptor {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum TypeSpecific {
        /// Applicable only for the string type. All sizes are measured in bytes, not code points.
        #[prost(message, tag = "20")]
        StringStats(super::StringStats),
        /// Relevant for variable-length List, Map.
        #[prost(message, tag = "21")]
        ListStats(super::ListStats),
        /// Statistics specific to boolean fields.
        #[prost(message, tag = "22")]
        BooleanStats(super::BooleanStats),
        /// Statistics specific to decimal fields (128-bit precision).
        #[prost(message, tag = "23")]
        DecimalStats(super::DecimalStats),
        /// Statistics specific to floating-point fields (f32, f64).
        #[prost(message, tag = "24")]
        FloatingStats(super::FloatingStats),
        /// Statistics for binary types (where binary is treated as a container of bytes).
        #[prost(message, tag = "25")]
        BinaryStats(super::BinaryStats),
    }
}
/// Provides the minimum and maximum values for the stored sequence.
///   - For all data types, these stats ignore null values.
///   - For floating-point types, these stats ignore NaN values but consider
///     positive and negative infinity.
///   - For binary and string types, the min and max values are computed
///     based on byte-lexicographic ordering.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RangeStats {
    #[prost(message, optional, tag = "1")]
    pub min_value: ::core::option::Option<super::common::AnyValue>,
    #[prost(bool, tag = "2")]
    pub min_inclusive: bool,
    #[prost(message, optional, tag = "3")]
    pub max_value: ::core::option::Option<super::common::AnyValue>,
    #[prost(bool, tag = "4")]
    pub max_inclusive: bool,
}
/// Applicable only for the `string` type. All sizes are measured in bytes, not code points.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct StringStats {
    /// Indicates the minimum size of the string, in bytes.
    #[prost(fixed64, tag = "1")]
    pub min_size: u64,
    /// Indicates the minimum size of a non-empty string, in bytes.
    #[prost(fixed64, optional, tag = "2")]
    pub min_non_empty_size: ::core::option::Option<u64>,
    /// Indicates the maximum size of the string, in bytes.
    #[prost(fixed64, tag = "3")]
    pub max_size: u64,
    /// Represents the number of value slots containing ASCII-only strings
    /// (strings with only code points below 128).
    #[prost(fixed64, optional, tag = "4")]
    pub ascii_count: ::core::option::Option<u64>,
}
/// Statistics specific to boolean fields.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BooleanStats {
    /// The number of true values in the boolean field.
    #[prost(fixed64, tag = "1")]
    pub true_count: u64,
    /// The number of false values in the boolean field.
    #[prost(fixed64, tag = "2")]
    pub false_count: u64,
}
/// Relevant for variable-length List and Map.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListStats {
    /// Minimum length of the container (`List`, `Map`).
    #[prost(fixed64, tag = "1")]
    pub min_length: u64,
    /// Minimum length of non-empty container.
    #[prost(fixed64, optional, tag = "2")]
    pub min_non_empty_length: ::core::option::Option<u64>,
    /// Maximum length of the container (`List`, `Map`).
    #[prost(fixed64, tag = "3")]
    pub max_length: u64,
}
/// Relevant for Binary stats.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BinaryStats {
    /// Minimum length of the binary chunk.
    #[prost(fixed64, tag = "1")]
    pub min_length: u64,
    /// Minimum length of non-empty container.
    #[prost(fixed64, optional, tag = "2")]
    pub min_non_empty_length: ::core::option::Option<u64>,
    /// Maximum length of the binary chunk.
    #[prost(fixed64, tag = "3")]
    pub max_length: u64,
}
/// Statistics specific to decimal fields (128-bit precision).
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DecimalStats {
    /// Number of decimal values that are zero.
    #[prost(fixed64, tag = "1")]
    pub zero_count: u64,
    /// Number of decimal values that are positive (greater than zero).
    #[prost(fixed64, tag = "2")]
    pub positive_count: u64,
    /// Number of decimal values that are negative (less than zero).
    #[prost(fixed64, tag = "3")]
    pub negative_count: u64,
    /// Number of decimal values that are NaN (Not a Number).
    #[prost(fixed64, tag = "4")]
    pub nan_count: u64,
}
/// Statistics specific to floating-point fields (f32, f64).
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FloatingStats {
    /// Number of floating-point values that are zero.
    #[prost(fixed64, tag = "1")]
    pub zero_count: u64,
    /// Number of floating-point values that are positive (greater than zero).
    #[prost(fixed64, tag = "2")]
    pub positive_count: u64,
    /// Number of floating-point values that are negative (less than zero).
    #[prost(fixed64, tag = "3")]
    pub negative_count: u64,
    /// Number of floating-point values that are NaN (Not a Number).
    #[prost(fixed64, tag = "4")]
    pub nan_count: u64,
    /// Number of floating-point values that are positive infinity.
    #[prost(fixed64, tag = "5")]
    pub positive_infinity_count: u64,
    /// Number of floating-point values that are negative infinity.
    #[prost(fixed64, tag = "6")]
    pub negative_infinity_count: u64,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CardinalityInfo {
    #[prost(fixed64, optional, tag = "1")]
    pub count: ::core::option::Option<u64>,
    #[prost(bool, tag = "2")]
    pub is_estimate: bool,
    #[prost(message, optional, tag = "3")]
    pub hll_sketch: ::core::option::Option<HllSketchV1>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MembershipFilters {
    /// Bloom filter sketches.
    /// Note: These filters exist only at the stripe level. To determine if a value
    /// exists in a shard, queries must probe all stripe-level filters across all stripes.
    #[prost(message, optional, tag = "1")]
    pub sbbf: ::core::option::Option<SplitBlockBloomFilter>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct HllSketchV1 {
    /// Hash algorithm used (e.g., "xxh3_64")
    #[prost(string, tag = "1")]
    pub hash_algorithm: ::prost::alloc::string::String,
    /// Hash function seed
    #[prost(fixed64, tag = "2")]
    pub hash_seed: u64,
    /// / Number of bits for indexing HLL sub-streams; the number of counters is `pow(2, bits_per_index)`.
    #[prost(fixed32, tag = "3")]
    pub bits_per_index: u32,
    /// / Lookup table.
    #[prost(bytes = "vec", tag = "4")]
    pub counters: ::prost::alloc::vec::Vec<u8>,
}
/// Split-Block Bloom Filter (SBBF) for efficient approximate membership queries.
/// Provides cache-efficient membership testing with configurable false positive rates.
/// This message is typically serialized and stored within a MembershipFilters.sbbf
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SplitBlockBloomFilter {
    /// Number of 256-bit (32 bytes) blocks in the filter
    #[prost(fixed64, tag = "1")]
    pub num_blocks: u64,
    /// Target false positive probability (e.g., 0.01 for 1%)
    #[prost(double, tag = "2")]
    pub target_fpp: f64,
    /// Number of distinct values inserted into the filter
    #[prost(fixed64, tag = "3")]
    pub num_values: u64,
    /// Hash algorithm used (e.g., "xxh3_64")
    #[prost(string, tag = "4")]
    pub hash_algorithm: ::prost::alloc::string::String,
    /// Hash function seed
    #[prost(fixed64, tag = "5")]
    pub hash_seed: u64,
    /// The filter data as a sequence of 256-bit blocks
    #[prost(bytes = "vec", tag = "6")]
    pub data: ::prost::alloc::vec::Vec<u8>,
}
/// Stripe-level field descriptor: stats and encoding.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StripeFieldDescriptor {
    #[prost(message, optional, tag = "1")]
    pub field: ::core::option::Option<FieldDescriptor>,
    /// A list of data encodings, each offering an alternative way to represent the sequence
    /// of values. Typically, there is just one DataEncoding in this list.
    #[prost(message, repeated, tag = "2")]
    pub encodings: ::prost::alloc::vec::Vec<DataEncoding>,
}
/// The data encoding for a field can be either native to Amudai, or it can reference data
/// stored externally in a different format.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataEncoding {
    #[prost(oneof = "data_encoding::Kind", tags = "1, 2")]
    pub kind: ::core::option::Option<data_encoding::Kind>,
}
/// Nested message and enum types in `DataEncoding`.
pub mod data_encoding {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Kind {
        #[prost(message, tag = "1")]
        Native(super::NativeDataEncoding),
        #[prost(message, tag = "2")]
        Parquet(super::ExternalParquetDataEncoding),
    }
}
/// NativeDataEncoding of a field, expressed through one or more encoded buffers.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NativeDataEncoding {
    #[prost(message, repeated, tag = "1")]
    pub buffers: ::prost::alloc::vec::Vec<EncodedBuffer>,
    #[prost(bool, tag = "10")]
    pub packed_group: bool,
}
/// Descriptor of a single Encoded Buffer: a stripe-scoped sequence of primitive values.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EncodedBuffer {
    /// Specifies the type of buffer and its function within the data encoding scheme
    /// for the specified field.
    #[prost(enumeration = "BufferKind", tag = "1")]
    pub kind: i32,
    /// A reference to the entire encoded buffer, covering both the compressed data part
    /// and the block map if present.
    #[prost(message, optional, tag = "2")]
    pub buffer: ::core::option::Option<super::common::DataRef>,
    /// A reference to the block map, which is the tail end of the encoded buffer.
    #[prost(message, optional, tag = "3")]
    pub block_map: ::core::option::Option<super::common::DataRef>,
    /// The total number of independently compressed blocks in the buffer, applicable
    /// if a block-based structure is used.
    #[prost(fixed64, optional, tag = "4")]
    pub block_count: ::core::option::Option<u64>,
    /// When block-based compression is applied (block_count != 0), this specifies whether
    /// checksums are appended to each encoded block. These checksums cover the block header
    /// and block data.
    #[prost(bool, tag = "5")]
    pub block_checksums: bool,
    /// If true, presence information (i.e., nulls) is embedded in the value blocks.
    #[prost(bool, tag = "6")]
    pub embedded_presence: bool,
    /// If true, offsets for variable-sized values are stored within each block rather than
    /// as a separate encoded buffer.
    /// This is relevant only for string and binary fields and is only valid within a buffer
    /// with `BufferKind::DATA`.
    #[prost(bool, tag = "7")]
    pub embedded_offsets: bool,
    /// An optional numerical buffer identifier. If present, it must be unique within the
    /// containing DataEncoding.
    /// This ID can reference a specific auxiliary encoded buffer from within the encoded
    /// blocks of the primary data buffer (e.g., referencing a specific value dictionary
    /// if there are multiple).
    #[prost(fixed32, optional, tag = "20")]
    pub buffer_id: ::core::option::Option<u32>,
    /// Index of the corresponding block for the "virtual" buffer within the packed group.
    #[prost(fixed32, optional, tag = "21")]
    pub packed_group_index: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExternalParquetDataEncoding {
    #[prost(message, repeated, tag = "1")]
    pub file_column_refs: ::prost::alloc::vec::Vec<ParquetFileColumnRef>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ParquetFileColumnRef {
    #[prost(message, optional, tag = "1")]
    pub file_ref: ::core::option::Option<super::common::DataRef>,
    #[prost(message, repeated, tag = "2")]
    pub column_chunks: ::prost::alloc::vec::Vec<ParquetColumnChunkRef>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ParquetColumnChunkRef {
    #[prost(enumeration = "ParquetStorageType", tag = "1")]
    pub storage_type: i32,
    #[prost(fixed32, tag = "2")]
    pub schema_element_id: u32,
    #[prost(fixed32, tag = "3")]
    pub row_group_id: u32,
    #[prost(fixed32, tag = "4")]
    pub column_chunk_id: u32,
    #[prost(string, optional, tag = "5")]
    pub file_url: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "6")]
    pub data_pages_range: ::core::option::Option<super::common::UInt64Range>,
    #[prost(fixed64, tag = "7")]
    pub data_page_count: u64,
    #[prost(message, optional, tag = "8")]
    pub dictionary_range: ::core::option::Option<super::common::UInt64Range>,
    #[prost(message, optional, tag = "9")]
    pub data_page_map: ::core::option::Option<super::common::DataRef>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IndexCollection {
    #[prost(message, repeated, tag = "1")]
    pub index_descriptors: ::prost::alloc::vec::Vec<IndexDescriptor>,
}
/// Describes the key characteristics of an index. Most details depend on the specific index type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IndexDescriptor {
    /// Identifies the type of index
    #[prost(string, tag = "1")]
    pub index_type: ::prost::alloc::string::String,
    /// A flexible key-value property list for custom index settings or metadata
    #[prost(message, repeated, tag = "2")]
    pub properties: ::prost::alloc::vec::Vec<super::common::NameValuePair>,
    /// The fields of the shard that are indexed.
    #[prost(message, repeated, tag = "3")]
    pub indexed_fields: ::prost::alloc::vec::Vec<IndexedField>,
    /// List of objects produced/used by the index
    #[prost(message, repeated, tag = "4")]
    pub artifacts: ::prost::alloc::vec::Vec<IndexArtifact>,
    /// Size of the index in bytes
    #[prost(fixed64, optional, tag = "5")]
    pub index_size: ::core::option::Option<u64>,
}
/// Storage artifact produced or used by the index.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IndexArtifact {
    /// Name or ID of the artifact; may be empty.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Artifact properties; specific to the index type and controlled by the index builder.
    #[prost(message, repeated, tag = "2")]
    pub properties: ::prost::alloc::vec::Vec<super::common::NameValuePair>,
    /// Data reference for the artifact.
    #[prost(message, optional, tag = "3")]
    pub data_ref: ::core::option::Option<super::common::DataRef>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct IndexedField {
    /// A list of schema IDs for shard fields that together form the composite key
    /// for a single logical indexed value.
    /// In most cases, this list will contain only one shard field, representing
    /// a straightforward indexing of that field's values.
    /// However, multiple shard fields can be included for cases where a combination
    /// of their values is indexed as a composite key.
    #[prost(fixed32, repeated, tag = "1")]
    pub schema_ids: ::prost::alloc::vec::Vec<u32>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BufferKind {
    /// Stores the sequence of actual values, which can be either fixed-size primitives
    /// or variable-sized byte slices concatenated in sequence.
    Data = 0,
    /// Indicates the presence of null values within the field. It stores presence flags
    /// for each logical position, conceptually as a sequence of bool values, where `true`
    /// indicates the presence of a value at the corresponding position and `false`
    /// indicates a null.
    Presence = 1,
    /// Works alongside the DATA buffer for variable-sized types such as string and binary.
    /// It stores the end-of-value offsets of the corresponding byte slices in the DATA buffer.
    /// Logically, this is a sequence of `uint64` values starting from zero, with a length
    /// one greater than the number of value slots.
    /// A variable-sized value at logical position `i` has a byte range `offsets\[i\]..offsets\[i + 1\]`
    /// in the DATA buffer.
    Offsets = 2,
    /// Supports the dictionary encoding of values. It associates a unique integer ID (`uint32`)
    /// with each distinct value of the field within the stripe, while the DATA buffer stores
    /// a sequence of these dictionary IDs.
    ValueDictionary = 3,
    /// An opaque dictionary buffer used by the general-purpose block compressor as a shared
    /// dictionary across multiple blocks. A block that uses this dictionary will reference
    /// the corresponding dictionary buffer in its header.
    OpaqueDictionary = 4,
    /// Stores numeric range index data for numeric fields.
    RangeIndex = 5,
}
impl BufferKind {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Data => "DATA",
            Self::Presence => "PRESENCE",
            Self::Offsets => "OFFSETS",
            Self::ValueDictionary => "VALUE_DICTIONARY",
            Self::OpaqueDictionary => "OPAQUE_DICTIONARY",
            Self::RangeIndex => "RANGE_INDEX",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DATA" => Some(Self::Data),
            "PRESENCE" => Some(Self::Presence),
            "OFFSETS" => Some(Self::Offsets),
            "VALUE_DICTIONARY" => Some(Self::ValueDictionary),
            "OPAQUE_DICTIONARY" => Some(Self::OpaqueDictionary),
            "RANGE_INDEX" => Some(Self::RangeIndex),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ParquetStorageType {
    Boolean = 0,
    Int32 = 1,
    Int64 = 2,
    Int96 = 3,
    Float = 4,
    Double = 5,
    ByteArray = 6,
    FixedLenByteArray = 7,
}
impl ParquetStorageType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Boolean => "BOOLEAN",
            Self::Int32 => "INT32",
            Self::Int64 => "INT64",
            Self::Int96 => "INT96",
            Self::Float => "FLOAT",
            Self::Double => "DOUBLE",
            Self::ByteArray => "BYTE_ARRAY",
            Self::FixedLenByteArray => "FIXED_LEN_BYTE_ARRAY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BOOLEAN" => Some(Self::Boolean),
            "INT32" => Some(Self::Int32),
            "INT64" => Some(Self::Int64),
            "INT96" => Some(Self::Int96),
            "FLOAT" => Some(Self::Float),
            "DOUBLE" => Some(Self::Double),
            "BYTE_ARRAY" => Some(Self::ByteArray),
            "FIXED_LEN_BYTE_ARRAY" => Some(Self::FixedLenByteArray),
            _ => None,
        }
    }
}
