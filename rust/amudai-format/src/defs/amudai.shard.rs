// This file is @generated by prost-build.
/// Shard Directory serves as the starting point for accessing any shard operation.
/// It can be saved either in its own file, as part of a larger "shard directory"
/// file, or within the entire encoded shard blob.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShardDirectory {
    /// Reference to a `Schema` message.
    #[prost(message, optional, tag = "1")]
    pub schema_ref: ::core::option::Option<super::common::DataRef>,
    /// Reference to a `ShardProperties` message.
    #[prost(message, optional, tag = "2")]
    pub properties_ref: ::core::option::Option<super::common::DataRef>,
    /// Reference to a `DataRefArray` (list of field descriptor refs).
    #[prost(message, optional, tag = "3")]
    pub field_list_ref: ::core::option::Option<super::common::DataRef>,
    /// Reference to a `StripeList` message.
    #[prost(message, optional, tag = "4")]
    pub stripe_list_ref: ::core::option::Option<super::common::DataRef>,
    /// Reference to a `UrlList` message.
    #[prost(message, optional, tag = "5")]
    pub url_list_ref: ::core::option::Option<super::common::DataRef>,
    /// Reference to a shard-scoped `IndexCollection` message.
    #[prost(message, optional, tag = "6")]
    pub indexes_ref: ::core::option::Option<super::common::DataRef>,
    #[prost(fixed64, tag = "7")]
    pub total_record_count: u64,
    #[prost(fixed64, tag = "8")]
    pub deleted_record_count: u64,
    #[prost(fixed64, tag = "9")]
    pub stripe_count: u64,
    #[prost(fixed64, optional, tag = "10")]
    pub stored_data_size: ::core::option::Option<u64>,
    #[prost(fixed64, optional, tag = "11")]
    pub stored_index_size: ::core::option::Option<u64>,
    #[prost(fixed64, optional, tag = "12")]
    pub plain_data_size: ::core::option::Option<u64>,
}
/// Standard and custom name-value pairs associated with the shard.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShardProperties {
    /// `creation_min` and `creation_max` define the range of timestamps marking
    /// the shard's creation period. When a shard is first created, both timestamps
    /// are identical. However, they may vary as shards undergo merging.
    #[prost(message, optional, tag = "1")]
    pub creation_min: ::core::option::Option<super::common::DateTimeUtc>,
    #[prost(message, optional, tag = "2")]
    pub creation_max: ::core::option::Option<super::common::DateTimeUtc>,
    #[prost(message, repeated, tag = "3")]
    pub standard_properties: ::prost::alloc::vec::Vec<super::common::NameValuePair>,
    #[prost(message, repeated, tag = "4")]
    pub custom_properties: ::prost::alloc::vec::Vec<super::common::NameValuePair>,
}
/// A list of all unique artifact URLs used within this shard, meaning they are referenced
/// by any of its `DataRef` elements.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UrlList {
    #[prost(string, repeated, tag = "1")]
    pub urls: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// The records within a shard are segmented into multiple horizontal data stripes.
/// Each shard contains at least one data stripe, with no set limit on stripe size;
/// a single stripe can encompass an entire shard.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StripeList {
    #[prost(message, repeated, tag = "1")]
    pub stripes: ::prost::alloc::vec::Vec<StripeDirectory>,
}
/// A complete directory of a stripe.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StripeDirectory {
    /// Reference to a `StripeProperties` message.
    #[prost(message, optional, tag = "1")]
    pub properties_ref: ::core::option::Option<super::common::DataRef>,
    /// Reference to a `DataRefArray` stripe field descriptors list.
    #[prost(message, optional, tag = "2")]
    pub field_list_ref: ::core::option::Option<super::common::DataRef>,
    /// Reference to a stripe-scoped `IndexCollection` message.
    #[prost(message, optional, tag = "3")]
    pub indexes_ref: ::core::option::Option<super::common::DataRef>,
    #[prost(fixed64, tag = "4")]
    pub total_record_count: u64,
    #[prost(fixed64, tag = "5")]
    pub deleted_record_count: u64,
    #[prost(fixed64, optional, tag = "6")]
    pub stored_data_size: ::core::option::Option<u64>,
    #[prost(fixed64, optional, tag = "7")]
    pub stored_index_size: ::core::option::Option<u64>,
    #[prost(fixed64, optional, tag = "8")]
    pub plain_data_size: ::core::option::Option<u64>,
    /// The logical offset of the first record in this stripe within the
    /// containing shard.
    /// This value does not account for deleted records in preceding stripes.
    #[prost(fixed64, tag = "9")]
    pub record_offset: u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StripeProperties {
    #[prost(message, repeated, tag = "1")]
    pub standard_properties: ::prost::alloc::vec::Vec<super::common::NameValuePair>,
    #[prost(message, repeated, tag = "2")]
    pub custom_properties: ::prost::alloc::vec::Vec<super::common::NameValuePair>,
}
/// At the stripe level, a FieldDescriptor connects an abstract schema field definition
/// with its actual storage representation, including statistics and summaries of the values
/// in that stripe.
/// At the shard level, the FieldDescriptor only contains statistics for the field across
/// the entire shard.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FieldDescriptor {
    /// Indicates the number of logical "value slots" (logical positions)
    /// in this field's stored sequence.
    #[prost(fixed64, tag = "1")]
    pub position_count: u64,
    /// If present, this specifies the number of logical value slots containing `null` values.
    #[prost(fixed64, optional, tag = "2")]
    pub null_count: ::core::option::Option<u64>,
    /// If present, this indicates that all value slots contain the same value,
    /// including the possibility that all values are null. Such a field might
    /// not have any data encodings at the stripe level.
    #[prost(message, optional, tag = "3")]
    pub constant_value: ::core::option::Option<super::common::AnyValue>,
    /// Dictionary size
    #[prost(fixed64, optional, tag = "4")]
    pub dictionary_size: ::core::option::Option<u64>,
    /// For a Boolean field, this denotes the number of value slots equal to true.
    #[prost(fixed64, optional, tag = "5")]
    pub true_count: ::core::option::Option<u64>,
    /// For a floating-point type, this specifies the number of value slots containing NaN.
    #[prost(fixed64, optional, tag = "6")]
    pub nan_count: ::core::option::Option<u64>,
    /// Provides the minimum and maximum values for the stored sequence, where the range bounds
    /// may be inclusive or exclusive.
    #[prost(message, optional, tag = "7")]
    pub range_stats: ::core::option::Option<RangeStats>,
    /// Estimates the number of distinct values in the field, with null counted as a single
    /// distinct value.
    #[prost(message, optional, tag = "8")]
    pub cardinality: ::core::option::Option<CardinalityInfo>,
    /// Optional approximate membership query (AMQ) filters for the values of the field.
    #[prost(message, optional, tag = "9")]
    pub membership_filters: ::core::option::Option<MembershipFilters>,
    /// Optional indexes specific to the field (these can exist alongside multi-field indexes
    /// at the shard or stripe level).
    #[prost(message, optional, tag = "10")]
    pub indexes: ::core::option::Option<IndexCollection>,
    /// Additional properties associated with the field.
    #[prost(message, repeated, tag = "11")]
    pub properties: ::prost::alloc::vec::Vec<super::common::NameValuePair>,
    #[prost(message, repeated, tag = "40")]
    pub custom_properties: ::prost::alloc::vec::Vec<super::common::NameValuePair>,
    /// The sum of all Amudai encoded buffer sizes for this field, excluding references to external
    /// artifacts (e.g., columns in Parquet files).
    #[prost(fixed64, optional, tag = "41")]
    pub stored_data_size: ::core::option::Option<u64>,
    #[prost(fixed64, optional, tag = "42")]
    pub stored_index_size: ::core::option::Option<u64>,
    #[prost(fixed64, optional, tag = "43")]
    pub plain_data_size: ::core::option::Option<u64>,
    #[prost(oneof = "field_descriptor::TypeSpecific", tags = "20, 21")]
    pub type_specific: ::core::option::Option<field_descriptor::TypeSpecific>,
}
/// Nested message and enum types in `FieldDescriptor`.
pub mod field_descriptor {
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum TypeSpecific {
        /// Applicable only for the string type. All sizes are measured in bytes, not code points.
        #[prost(message, tag = "20")]
        StringStats(super::StringStats),
        /// Relevant for variable-length List, Map, and binary types (where binary is treated
        /// as a container of bytes).
        #[prost(message, tag = "21")]
        ContainerStats(super::ContainerStats),
    }
}
/// Provides the minimum and maximum values for the stored sequence.
///   - For all data types, these stats ignore null values.
///   - For floating-point types, these stats ignore NaN values but consider
///     positive and negative infinity.
///   - For binary and string types, the min and max values are computed
///     based on byte-lexicographic ordering.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RangeStats {
    #[prost(message, optional, tag = "1")]
    pub min_value: ::core::option::Option<super::common::AnyValue>,
    #[prost(bool, tag = "2")]
    pub min_inclusive: bool,
    #[prost(message, optional, tag = "3")]
    pub max_value: ::core::option::Option<super::common::AnyValue>,
    #[prost(bool, tag = "4")]
    pub max_inclusive: bool,
}
/// Applicable only for the `string` type. All sizes are measured in bytes, not code points.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct StringStats {
    /// Indicates the minimum size of the string, in bytes.
    #[prost(fixed64, tag = "1")]
    pub min_size: u64,
    /// Indicates the minimum size of a non-empty string, in bytes.
    #[prost(fixed64, optional, tag = "2")]
    pub min_non_empty_size: ::core::option::Option<u64>,
    /// Indicates the maximum size of the string, in bytes.
    #[prost(fixed64, tag = "3")]
    pub max_size: u64,
    /// Represents the number of value slots containing ASCII-only strings
    /// (strings with only code points below 128).
    #[prost(fixed64, optional, tag = "4")]
    pub ascii_count: ::core::option::Option<u64>,
}
/// Relevant for variable-length List, Map, and binary types
/// (where binary is treated as a container of bytes).
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ContainerStats {
    /// Minimum length of the container (`List`, `Map` or `Binary`).
    #[prost(fixed64, tag = "1")]
    pub min_length: u64,
    /// Minimum length of non-empty container.
    #[prost(fixed64, optional, tag = "2")]
    pub min_non_empty_length: ::core::option::Option<u64>,
    /// Maximum length of the container (`List`, `Map` or `Binary`).
    #[prost(fixed64, tag = "3")]
    pub max_length: u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CardinalityInfo {
    #[prost(fixed64, optional, tag = "1")]
    pub count: ::core::option::Option<u64>,
    #[prost(bool, tag = "2")]
    pub is_estimate: bool,
    #[prost(message, optional, tag = "3")]
    pub hll_sketch: ::core::option::Option<super::common::AnyValue>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MembershipFilters {
    #[prost(message, repeated, tag = "1")]
    pub bloom_filters: ::prost::alloc::vec::Vec<super::common::AnyValue>,
}
/// Stripe-level field descriptor: stats and encoding.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StripeFieldDescriptor {
    #[prost(message, optional, tag = "1")]
    pub field: ::core::option::Option<FieldDescriptor>,
    /// A list of data encodings, each offering an alternative way to represent the sequence
    /// of values. Typically, there is just one DataEncoding in this list.
    #[prost(message, repeated, tag = "2")]
    pub encodings: ::prost::alloc::vec::Vec<DataEncoding>,
}
/// The data encoding for a field can be either native to Amudai, or it can reference data
/// stored externally in a different format.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataEncoding {
    #[prost(oneof = "data_encoding::Kind", tags = "1, 2")]
    pub kind: ::core::option::Option<data_encoding::Kind>,
}
/// Nested message and enum types in `DataEncoding`.
pub mod data_encoding {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Kind {
        #[prost(message, tag = "1")]
        Native(super::NativeDataEncoding),
        #[prost(message, tag = "2")]
        Parquet(super::ExternalParquetDataEncoding),
    }
}
/// NativeDataEncoding of a field, expressed through one or more encoded buffers.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NativeDataEncoding {
    #[prost(message, repeated, tag = "1")]
    pub buffers: ::prost::alloc::vec::Vec<EncodedBuffer>,
    #[prost(bool, tag = "10")]
    pub packed_group: bool,
}
/// Descriptor of a single Encoded Buffer: a stripe-scoped sequence of primitive values.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EncodedBuffer {
    /// Specifies the type of buffer and its function within the data encoding scheme
    /// for the specified field.
    #[prost(enumeration = "BufferKind", tag = "1")]
    pub kind: i32,
    /// A reference to the entire encoded buffer, covering both the compressed data part
    /// and the block map if present.
    #[prost(message, optional, tag = "2")]
    pub buffer: ::core::option::Option<super::common::DataRef>,
    /// A reference to the block map, which is the tail end of the encoded buffer.
    #[prost(message, optional, tag = "3")]
    pub block_map: ::core::option::Option<super::common::DataRef>,
    /// The total number of independently compressed blocks in the buffer, applicable
    /// if a block-based structure is used.
    #[prost(fixed64, optional, tag = "4")]
    pub block_count: ::core::option::Option<u64>,
    /// When block-based compression is applied (block_count != 0), this specifies whether
    /// checksums are appended to each encoded block. These checksums cover the block header
    /// and block data.
    #[prost(bool, tag = "5")]
    pub block_checksums: bool,
    /// If true, presence information (i.e., nulls) is embedded in the value blocks.
    #[prost(bool, tag = "6")]
    pub embedded_presence: bool,
    /// If true, offsets for variable-sized values are stored within each block rather than
    /// as a separate encoded buffer.
    /// This is relevant only for string and binary fields and is only valid within a buffer
    /// with `BufferKind::DATA`.
    #[prost(bool, tag = "7")]
    pub embedded_offsets: bool,
    /// An optional numerical buffer identifier. If present, it must be unique within the
    /// containing DataEncoding.
    /// This ID can reference a specific auxiliary encoded buffer from within the encoded
    /// blocks of the primary data buffer (e.g., referencing a specific value dictionary
    /// if there are multiple).
    #[prost(fixed32, optional, tag = "20")]
    pub buffer_id: ::core::option::Option<u32>,
    /// Index of the corresponding block for the "virtual" buffer within the packed group.
    #[prost(fixed32, optional, tag = "21")]
    pub packed_group_index: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValueDictionaryHeader {
    #[prost(fixed32, tag = "1")]
    pub value_type: u32,
    #[prost(fixed32, optional, tag = "2")]
    pub null_id: ::core::option::Option<u32>,
    #[prost(message, optional, tag = "3")]
    pub values_section_ref: ::core::option::Option<super::common::DataRef>,
    #[prost(message, optional, tag = "4")]
    pub sorted_ids_section_ref: ::core::option::Option<super::common::DataRef>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DictionaryVarSizeValuesSection {
    #[prost(message, optional, tag = "1")]
    pub values: ::core::option::Option<super::common::BytesList>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DictionaryFixedSizeValuesSection {
    #[prost(bytes = "vec", tag = "1")]
    pub values: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DictionarySortedIdsSection {
    #[prost(fixed32, repeated, tag = "1")]
    pub sorted_ids: ::prost::alloc::vec::Vec<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExternalParquetDataEncoding {
    #[prost(message, repeated, tag = "1")]
    pub file_column_refs: ::prost::alloc::vec::Vec<ParquetFileColumnRef>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ParquetFileColumnRef {
    #[prost(message, optional, tag = "1")]
    pub file_ref: ::core::option::Option<super::common::DataRef>,
    #[prost(message, repeated, tag = "2")]
    pub column_chunks: ::prost::alloc::vec::Vec<ParquetColumnChunkRef>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ParquetColumnChunkRef {
    #[prost(enumeration = "ParquetStorageType", tag = "1")]
    pub storage_type: i32,
    #[prost(fixed32, tag = "2")]
    pub schema_element_id: u32,
    #[prost(fixed32, tag = "3")]
    pub row_group_id: u32,
    #[prost(fixed32, tag = "4")]
    pub column_chunk_id: u32,
    #[prost(string, optional, tag = "5")]
    pub file_url: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "6")]
    pub data_pages_range: ::core::option::Option<super::common::UInt64Range>,
    #[prost(fixed64, tag = "7")]
    pub data_page_count: u64,
    #[prost(message, optional, tag = "8")]
    pub dictionary_range: ::core::option::Option<super::common::UInt64Range>,
    #[prost(message, optional, tag = "9")]
    pub data_page_map: ::core::option::Option<super::common::DataRef>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IndexCollection {
    #[prost(message, repeated, tag = "1")]
    pub index_descriptors: ::prost::alloc::vec::Vec<IndexDescriptor>,
}
/// Outlines the key characteristics of an index. Most details are specific to the type of index.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IndexDescriptor {
    #[prost(string, tag = "1")]
    pub index_type: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub properties: ::prost::alloc::vec::Vec<super::common::NameValuePair>,
    #[prost(message, repeated, tag = "3")]
    pub indexed_fields: ::prost::alloc::vec::Vec<IndexedField>,
    #[prost(message, repeated, tag = "4")]
    pub artifacts: ::prost::alloc::vec::Vec<super::common::DataRef>,
    #[prost(fixed64, optional, tag = "5")]
    pub index_size: ::core::option::Option<u64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IndexedField {
    #[prost(fixed32, repeated, tag = "1")]
    pub schema_ids: ::prost::alloc::vec::Vec<u32>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BufferKind {
    /// Stores the sequence of actual values, which can be either fixed-size primitives
    /// or variable-sized byte slices concatenated in sequence.
    Data = 0,
    /// Indicates the presence of null values within the field. It stores presence flags
    /// for each logical position, conceptually as a sequence of bool values, where `true`
    /// indicates the presence of a value at the corresponding position and `false`
    /// indicates a null.
    Presence = 1,
    /// Works alongside the DATA buffer for variable-sized types such as string and binary.
    /// It stores the end-of-value offsets of the corresponding byte slices in the DATA buffer.
    /// Logically, this is a sequence of `uint64` values starting from zero, with a length
    /// one greater than the number of value slots.
    /// A variable-sized value at logical position `i` has a byte range `offsets\[i\]..offsets\[i + 1\]`
    /// in the DATA buffer.
    Offsets = 2,
    /// Supports the dictionary encoding of values. It associates a unique integer ID (`uint32`)
    /// with each distinct value of the field within the stripe, while the DATA buffer stores
    /// a sequence of these dictionary IDs.
    ValueDictionary = 3,
    /// An opaque dictionary buffer used by the general-purpose block compressor as a shared
    /// dictionary across multiple blocks. A block that uses this dictionary will reference
    /// the corresponding dictionary buffer in its header.
    OpaqueDictionary = 4,
}
impl BufferKind {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Data => "DATA",
            Self::Presence => "PRESENCE",
            Self::Offsets => "OFFSETS",
            Self::ValueDictionary => "VALUE_DICTIONARY",
            Self::OpaqueDictionary => "OPAQUE_DICTIONARY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DATA" => Some(Self::Data),
            "PRESENCE" => Some(Self::Presence),
            "OFFSETS" => Some(Self::Offsets),
            "VALUE_DICTIONARY" => Some(Self::ValueDictionary),
            "OPAQUE_DICTIONARY" => Some(Self::OpaqueDictionary),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ParquetStorageType {
    Boolean = 0,
    Int32 = 1,
    Int64 = 2,
    Int96 = 3,
    Float = 4,
    Double = 5,
    ByteArray = 6,
    FixedLenByteArray = 7,
}
impl ParquetStorageType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Boolean => "BOOLEAN",
            Self::Int32 => "INT32",
            Self::Int64 => "INT64",
            Self::Int96 => "INT96",
            Self::Float => "FLOAT",
            Self::Double => "DOUBLE",
            Self::ByteArray => "BYTE_ARRAY",
            Self::FixedLenByteArray => "FIXED_LEN_BYTE_ARRAY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BOOLEAN" => Some(Self::Boolean),
            "INT32" => Some(Self::Int32),
            "INT64" => Some(Self::Int64),
            "INT96" => Some(Self::Int96),
            "FLOAT" => Some(Self::Float),
            "DOUBLE" => Some(Self::Double),
            "BYTE_ARRAY" => Some(Self::ByteArray),
            "FIXED_LEN_BYTE_ARRAY" => Some(Self::FixedLenByteArray),
            _ => None,
        }
    }
}
